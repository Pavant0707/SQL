CREATE DATABASE FUNCTIONS
USE FUNCTIONS

CREATE TABLE STUDENT(
ID INT,
NAME VARCHAR(100),
MARKS INT,
GENDER VARCHAR(100)
)
INSERT INTO STUDENT(ID,NAME,MARKS,GENDER) VALUES(1,'SAI',90,'MALE')
INSERT INTO STUDENT(ID,NAME,MARKS,GENDER) VALUES(2,'RAM',90,'MALE')
INSERT INTO STUDENT(ID,NAME,MARKS,GENDER) VALUES(3,'SAMANTHA',80,'FEMALE')
INSERT INTO STUDENT(ID,NAME,MARKS,GENDER) VALUES(4,'ANUSHKA',70,'FEMALE')

CREATE FUNCTION GETAVG(@MARKS INT)
RETURNS DECIMAL(10,2)
AS
BEGIN
DECLARE @AVERAGE DECIMAL(10,2)
SELECT  @AVERAGE =AVG(@MARKS)
FROM STUDENT
RETURN @AVERAGE
END;
SELECT dbo.GETAVG();

CREATE or ALTER FUNCTION GETNAME(@ID INT)
RETURNS VARCHAR(100)
AS
BEGIN
DECLARE @NAME VARCHAR(100)
SELECT @NAME =NAME FROM STUDENT
WHERE ID=@ID
RETURN @NAME
END;
SELECT  dbo.GETNAME(1);
SELECT * FROM STUDENT

CREATE FUNCTION GETMESSAGE()
RETURNS VARCHAR(100)
AS
BEGIN
RETURN 'GFDGGFD'
END
SELECT dbo.GETMESSAGE();

CREATE FUNCTION NUMBER(@NUM INT)
RETURNS INT
AS
BEGIN
RETURN(@NUM*@NUM)
END;
SELECT dbo.NUMBER(2);

CREATE FUNCTION GETNUMBER(@NUM1 as INT,@NUM2 as INT)
RETURNS INT
AS
BEGIN
RETURN (@NUM1+@NUM2)
END;
SELECT dbo.GETNUMBER(2,2);

CREATE FUNCTION GETMAX(@a as bigint,@b as bigint)
RETURNS BIGINT AS
BEGIN
DECLARE @RESULT AS BIGINT
IF @a > @b
BEGIN
SELECT @RESULT=@a
END
ELSE 
SELECT @RESULT=@b
RETURN @RESULT
END;

CREATE FUNCTION GETMAX1(@a as bigint,@b as bigint)
RETURNS BIGINT AS
BEGIN
IF @a > @b
BEGIN
RETURN @a
END
ELSE
BEGIN
RETURN @b
END
RETURN 10;
END;

CREATE PROCEDURE GETSTUDENT
AS
BEGIN
SELECT * FROM STUDENT
END
 exec GETSTUDENT

CREATE PROCEDURE GETSTUDENT1
AS
BEGIN
SELECT NAME FROM STUDENT
END
EXEC GETSTUDENT1

CREATE PROCEDURE GETSTUDENTINFO
@ID INT
AS 
BEGIN
SELECT * FROM STUDENT WHERE ID=@ID
END
exec GETSTUDENTINFO 2

CREATE PROCEDURE GETSTUDENTINFO2
@ID INT,
@NAME VARCHAR(100)
AS
BEGIN
SELECT * FROM STUDENT WHERE @ID =ID AND @NAME=NAME
END
GETSTUDENTINFO2 2,'RAM'

BEGIN TRY
SELECT 10/0
END TRY

BEGIN CATCH
PRINT 'CAN NOT DIVIDE ZERO'
END CATCH

BEGIN TRY
UPDATE STUDENT SET MARKS='ACV' WHERE ID=1
END TRY
BEGIN CATCH
PRINT 'YOU CAN NOT INSERT INT'
END CATCH

SELECT NAME FROM STUDENT WHERE MARKS > 91;
IF @@ROWCOUNT = 0
PRINT 'NO STUDENTS';

DECLARE @COUNTER INT=1;
WHILE @COUNTER<=5
BEGIN
PRINT @COUNTER;
SET @COUNTER=@COUNTER+1;
END

SELECT * FROM STUDENT
INSERT INTO STUDENT VALUES (6,'AAA',50,'MALE')
UPDATE STUDENT SET NAME='BBB' WHERE ID=6
DELETE FROM STUDENT WHERE ID=6

CREATE TABLE DEMOTRIGGER(
ID INT,
NAME VARCHAR(100),
TRIGGERDATA VARCHAR(100))

CREATE TABLE AUDITDEMOTRIGGER(
ID INT IDENTITY(1,1),
NAME VARCHAR(100),
CREATEDAT DATETIME,
OPERATION VARCHAR(100))

CREATE TRIGGER DEMOTR
ON DEMOTRIGGER
AFTER INSERT 
AS
BEGIN
INSERT INTO AUDITDEMOTRIGGER(NAME,CREATEDAT,OPERATION)
SELECT T.NAME,GETDATE(),'INSERTED' FROM INSERTED T;
END;

INSERT INTO DEMOTRIGGER VALUES(5,'TRIGGER1','data_PROJECT')
SELECT * FROM AUDITDEMOTRIGGER
SELECT * FROM DEMOTRIGGER


CREATE TRIGGER DEMO_OF_TRIGGER
ON DEMOTRIGGER
AFTER DELETE
AS
BEGIN
INSERT INTO AUDITDEMOTRIGGER(NAME,CREATEDAT,OPERATION)
SELECT T.NAME,GETDATE(),'DELETED' FROM DELETED T;
END;
DELETE FROM DEMOTRIGGER WHERE  ID=3
SELECT * FROM AUDITDEMOTRIGGER
SELECT * FROM DEMOTRIGGER

CREATE TRIGGER DEMO_OF_TRIGGER1
ON DEMOTRIGGER
AFTER UPDATE
AS
BEGIN
SELECT * FROM INSERTED
SELECT * FROM DELETED
END;
UPDATE  DEMOTRIGGER SET NAME='TR1' WHERE ID=1

CREATE OR ALTER TRIGGER DEMO1
ON DEMOTRIGGER
AFTER INSERT
AS
BEGIN
SELECT * FROM INSERTED
END
INSERT INTO DEMOTRIGGER VALUES(2,'TR2','inserted')

CREATE TRIGGER DEMOTR3
ON DEMOTRIGGER
AFTER DELETE
AS
BEGIN
SELECT * FROM DELETED
END
DELETE FROM DEMOTRIGGER WHERE ID=8

CREATE TRIGGER DEMOTR4
ON DEMOTRIGGER
AFTER UPDATE
AS
BEGIN
   SELECT * FROM UPDATE
END;
UPDATE DEMOTRIGGER SET TRIGGERDATA='inserted' WHERE ID=3;

SELECT * FROM STUDENT
DECLARE STUDENT_CURSOR CURSOR SCROLL FOR SELECT * FROM STUDENT
OPEN STUDENT_CURSOR
FETCH FIRST FROM STUDENT_CURSOR
FETCH NEXT FROM STUDENT_CURSOR
FETCH LAST FROM STUDENT_CURSOR
FETCH PRIOR FROM STUDENT_CURSOR
FETCH ABSOLUTE 2 FROM STUDENT_CURSOR
FETCH RELATIVE 2 FROM STUDENT_CURSOR
CLOSE STUDENT_CURSOR
DEALLOCATE STUDENT_CURSOR